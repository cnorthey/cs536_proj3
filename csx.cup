/***
 *
 * This Is A Java CUP Specification For CSX-lite, a Small Subset
 * of The CSX Language, used In CS536
 * Extend this specification to handle all of CSX.
 *
 ***/

/* Preliminaries to set up and use the scanner.  */

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),  
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal CSXIdentifierToken     IDENTIFIER; 
terminal CSXIntLitToken			INTLIT;
terminal CSXToken     			SEMI, LPAREN, RPAREN, ASG, LBRACE, RBRACE;
terminal CSXToken     			PLUS, MINUS, EQ, NOTEQ, rw_IF;
terminal CSXToken     			rw_INT, rw_BOOL;
terminal CSXToken CAND;
terminal CSXToken CHARLIT;
terminal CSXToken COLON;
terminal CSXToken COMMA;
terminal CSXToken COR;
terminal CSXToken DECREMENT;
terminal CSXToken GEQ;
terminal CSXToken GT;
terminal CSXToken INCREMENT;
terminal CSXToken LBRACKET;
terminal CSXToken LEQ;
terminal CSXToken LT;
terminal CSXToken NOT;
terminal CSXToken RBRACKET;
terminal CSXToken rw_BREAK;
terminal CSXToken rw_CHAR;
terminal CSXToken rw_CLASS;
terminal CSXToken rw_CONST;
terminal CSXToken rw_CONTINUE;
terminal CSXToken rw_ELSE;
terminal CSXToken rw_FALSE;
terminal CSXToken rw_PRINT;
terminal CSXToken rw_READ;
terminal CSXToken rw_RETURN;
terminal CSXToken rw_TRUE;
terminal CSXToken rw_VOID;
terminal CSXToken rw_WHILE;
terminal CSXToken SLASH;
terminal CSXToken STRLIT;
terminal CSXToken TIMES;

/* Non terminals */
non terminal csxLiteNode     	prog;  
non terminal stmtsOption     	stmts;  
non terminal stmtNode	     	stmt;
non terminal exprNode			exp;
non terminal exprNode			unit; 
non terminal identNode	     	ident;
non terminal fieldDeclsOption	fielddecls; 
non terminal declNode			fielddecl;
non terminal typeNode			type;
non terminal Symbol		     	optionalSemi;
non terminal intLitNode		    intliteral;




start with prog;

prog		::= LBRACE:l fielddecls:f stmts:s RBRACE
			 {: RESULT=
				new csxLiteNode(f, s, l.linenum, l.colnum); :}	
		;
		
fielddecls
   			 ::=   fielddecl:f1 fielddecls:f2 
				 {: RESULT=
					new fieldDeclsNode(f1,f2, f1.linenum,f1.colnum); :}	
   			 |
				 {: RESULT=
					fieldDeclsNode.NULL; :}	
    		;
fielddecl
   			 ::= type:t     ident:i      SEMI 
				 {: RESULT=
					new varDeclNode(i,t,exprNode.NULL, t.linenum,t.colnum); :}	
    		;
    		
type
   			 ::= rw_INT:t
	 			{:
	  				 RESULT=new intTypeNode(t.linenum, t.colnum);
         		:}	
    		 |   rw_BOOL:t
				 {:
	  				 RESULT=new boolTypeNode(t.linenum, t.colnum);
         		:}	
    		; 
    		
stmts		::= stmt:s1  stmts:s2
			 {: RESULT=
			new stmtsNode(s1,s2,s1.linenum,s1.colnum);
			 :}	
		| 
			 {: RESULT= stmtsNode.NULL; :} 
		;
stmt		::= ident:id ASG exp:e SEMI
			 {: RESULT=
			new asgNode(new nameNode(id,id.linenum,id.colnum),e,id.linenum,id.colnum);
			 :}	

		| rw_IF:i LPAREN exp:e RPAREN  stmt:s
			 {:
			 RESULT=new ifThenNode(e,s, i.linenum,i.colnum); :}	
						
		|   LBRACE:l fielddecls:f stmts:s RBRACE optionalSemi
	 		{:
	  			 RESULT=new blockNode(f,s, l.linenum, l.colnum);
        	 :}	
        ;

/*
		| rw_WHILE:w LPAREN expr:e RPAREN stmt

		| ident:id COLON rw_WHILE:w LPAREN exp:e RPAREN stmt

		| ident:name INCREMENT SEMI

		| ident:name DECREMENT SEMI

		| rw_READ:r LPAREN readlist:rl RPAREN SEMI

		| rw_PRINT:p LPAREN printlist:pl RPAREN SEMI

		| ident:id PAREN RPAREN SEMI

		| ident:id PAREN args:as RPAREN SEMI

		| rw_RETURN SEMI

		| rw_RETURN expr:e SEMI

		| rw_BREAK ident:i SEMI

		| rw_CONTINUE ident:i SEMI

*/
         
exp		::= exp:leftval PLUS:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.PLUS,rightval,op.linenum,op.colnum); :}	
		| exp:leftval MINUS:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.MINUS,rightval,op.linenum,op.colnum); :}
		| unit:leftval EQ:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.EQ,rightval,op.linenum,op.colnum); :}	
		| unit:leftval NOTEQ:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.NOTEQ,rightval,op.linenum,op.colnum); :}
	    
		|   unit:u
			{: RESULT = u; :}
		;
unit    ::=	
            LPAREN exp:e RPAREN 
	   		 {: RESULT = e; :}
        |  ident:i		
			 {: RESULT = i; :}
		 | intliteral:l
	  		  {: RESULT = l; :}
		;
ident		::= IDENTIFIER:i
			 {: RESULT = new identNode(i.identifierText,
									   i.linenum,i.colnum); :}	
		;
		
intliteral
   ::= INTLIT:i
	 {: RESULT = new intLitNode(i.intValue, i.linenum,i.colnum);
         :}	
    ;
		
optionalSemi
   		 ::= SEMI
   		 |
   		 ;
